# Contributing to {{ project_name }}

Thank you for your interest in contributing to {{ project_name }}! This document provides guidelines for contributing to the project.

## Code of Conduct

We are committed to providing a welcoming and inclusive environment for all contributors. Please be respectful and considerate in all interactions.

## Getting Started

### Prerequisites

- Python {{ python_version }}+
- [uv](https://github.com/astral-sh/uv) (recommended)
- [just](https://github.com/casey/just) (optional, for task automation)
- Git

### Development Setup

1. Fork the repository on GitHub

2. Clone your fork:

```bash
git clone https://github.com/YOUR_USERNAME/{{ project_slug }}.git
cd {{ project_slug }}
```

3. Install dependencies:

```bash
uv sync --group dev
```

4. Install pre-commit hooks:

```bash
uv run pre-commit install
```

## Development Workflow

### Making Changes

1. Create a new branch:

```bash
git checkout -b feature/my-feature
```

2. Make your changes

3. Run tests:

```bash
uv run pytest
```

4. Run linters:

```bash
uvx nox -s fix
```

5. Commit your changes:

```bash
git add .
git commit -m "feat: add my feature"
```

We follow [Conventional Commits](https://www.conventionalcommits.org/) for commit messages. The commit message format is enforced by commitizen pre-commit hooks, which will validate your commit messages automatically.

**Valid commit message examples:**
- `feat: add new feature`
- `fix: resolve bug in calculation`
- `docs: update installation guide`
- `chore: update dependencies`
- `test: add tests for new feature`

### Running Tests

Run the test suite:

```bash
just test
# or directly: uv run pytest
```

Run tests with coverage:

```bash
just test-cov
# or directly: uv run pytest --cov={{ package_name }} --cov-report=html
```

Run tests across multiple Python versions:

```bash
uvx nox -s tests
```

### Code Quality

Format code and fix issues:

```bash
just format
```

Run linters and type checkers:

```bash
just lint
```

Run all quality checks:

```bash
just check
# or with nox: uvx nox -s fix
```

Run pre-commit hooks:

```bash
just pre-commit
```

### Documentation

Build documentation:

```bash
just docs
# or: uvx nox -s build_docs
```

Serve documentation locally:

```bash
just serve
# or: uvx nox -s serve_docs
```

View all available commands:

```bash
just --list
```

{% if include_examples %}
### Adding Examples

To add a new example notebook:

1. Create a new marimo notebook in `examples/<name>.py`:

   ```bash
   marimo new examples/<name>.py
   ```

2. Develop your example in the marimo editor

3. Test it runs correctly:

   ```bash
   marimo edit examples/<name>.py
   ```

4. Export for documentation:

   ```bash
   uvx nox -s export_examples
   ```

5. Add a link to your example in `docs/pages/examples.md`:

   ```markdown
   - [Example Name](../examples/<name>/) - Brief description
   ```

6. Commit all changes including the exported HTML

{% endif %}
## Submitting Changes

1. Push your changes to your fork:

```bash
git push origin feature/my-feature
```

2. Open a Pull Request on GitHub

3. Ensure all CI checks pass

4. Wait for review and address any feedback

## Pull Request Guidelines

- Write clear, descriptive PR titles following Conventional Commits
- Include a description of the changes
- Add tests for new functionality
- Update documentation as needed
- Ensure all tests pass
- Keep PRs focused and atomic

## Commit Message Convention

We use [Conventional Commits](https://www.conventionalcommits.org/) enforced by commitizen:

- `feat:` - New features (triggers minor version bump)
- `fix:` - Bug fixes (triggers patch version bump)
- `docs:` - Documentation changes
- `style:` - Code style changes (formatting, etc.)
- `refactor:` - Code refactoring
- `test:` - Adding or updating tests
- `chore:` - Maintenance tasks
- `perf:` - Performance improvements
- `ci:` - CI/CD changes

**Breaking changes:** Add `!` after the type or add `BREAKING CHANGE:` in the footer to trigger a major version bump.

**Example with scope:**
```bash
git commit -m "feat(api): add new endpoint for user data"
```

**Example with breaking change:**
```bash
git commit -m "feat!: redesign authentication system

BREAKING CHANGE: authentication now requires API keys instead of passwords"
```

The pre-commit hook will validate your commit messages and prevent commits that don't follow the convention.

## Release Process

Releases are fully automated through GitHub Actions when a new tag is pushed, with a **manual approval gate** before publishing to PyPI to ensure quality control.

```mermaid
graph LR
    A[Push Tag<br/>v*.*.*] --> B[changelog.yml]
    B --> C[Generate<br/>CHANGELOG.md]
    B --> D[Build Package<br/>validation]
    C --> E[Create PR]
    E --> F[Review & Merge<br/>PR]
    F --> G[publish-release.yml]
    G --> H[Create GitHub<br/>Release]
    H --> I{Manual<br/>Approval}
    I -->|Approve| J[Publish to PyPI]
    style I fill:#ff9,stroke:#333,stroke-width:2px
    style J fill:#9f9,stroke:#333,stroke-width:2px
```

### Initial Setup (One-time)

Before you can create releases, you need to configure two things:

#### 1. Create a Personal Access Token for Changelog Automation

1. **Create a Fine-grained Personal Access Token**:
   - Go to GitHub Settings â†’ Developer settings â†’ Personal access tokens â†’ Fine-grained tokens
   - Click "Generate new token"
   - Configure:
     - **Token name**: `CHANGELOG_AUTOMATION_TOKEN`
     - **Expiration**: 90 days or longer
     - **Repository access**: Only select repositories â†’ Choose this repository
     - **Permissions**:
       - Contents: Read and write
       - Pull requests: Read and write

2. **Add token as repository secret**:
   - Go to repository Settings â†’ Secrets and variables â†’ Actions
   - Click "New repository secret"
   - Name: `CHANGELOG_AUTOMATION_TOKEN`
   - Value: Paste your generated token

#### 2. Configure PyPI Environment with Required Reviewers

To enable the manual approval gate before PyPI publishing:

1. **Set up Trusted Publishing on PyPI** (if not already done):
   - Go to your PyPI project â†’ Manage â†’ Publishing
   - Add a new publisher with:
     - **Owner**: Your GitHub username/org
     - **Repository**: This repository name
     - **Workflow**: `publish-release.yml`
     - **Environment**: `pypi`

2. **Configure environment protection in GitHub**:
   - Go to repository Settings â†’ Environments
   - Click on the `pypi` environment (or create it if it doesn't exist)
   - Enable "Required reviewers"
   - Add yourself and/or other maintainers as required reviewers
   - Optionally set a wait timer (e.g., 5 minutes) for additional safety

This ensures that no package is published to PyPI without explicit approval from a maintainer.

### How It Works

1. **Tag a release:**
   ```bash
   git tag v0.2.0 -m "Release v0.2.0"
   git push origin v0.2.0
   ```

2. **Automated changelog workflow** (`changelog.yml`):
   - Generates changelog from conventional commits using git-cliff
   - Creates a **Pull Request** with the updated CHANGELOG.md
   - Builds the package distributions (wheels and sdist) for **immediate validation**
   - Stores distributions as workflow artifacts (reused later to avoid rebuilding)

3. **Review and merge the changelog PR:**
   - A maintainer reviews the generated changelog
   - Once approved, merge the PR to main

4. **Automated release workflow** (`publish-release.yml`):
   - Creates a GitHub Release with generated release notes
   - Attaches distribution files to the release
   - **Waits for manual approval** before proceeding to PyPI

5. **Manual approval for PyPI publishing:**
   - Designated reviewers receive a notification
   - Review the GitHub Release to verify everything is correct
   - Approve the deployment to publish to PyPI
   - Package is published using Trusted Publishing (OIDC, no tokens needed)

6. **Release notes generation:**
   - All commits since the last tag are analyzed
   - Commits are grouped by type (Added, Fixed, Documentation, etc.)
   - Only commits following conventional format are included
   - Breaking changes are highlighted

### Version Numbering

This project uses [Semantic Versioning](https://semver.org/):
- **Major** (1.0.0): Breaking changes
- **Minor** (0.1.0): New features (backward compatible)
- **Patch** (0.0.1): Bug fixes (backward compatible)

Use conventional commits to communicate the type of change, and select the appropriate version number when tagging.

## Questions?

If you have any questions, feel free to:

- Open an issue on GitHub
- Start a discussion in the repository

Thank you for contributing! ðŸŽ‰
