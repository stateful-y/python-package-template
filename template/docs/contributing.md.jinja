# Contributing to {{ project_name }}

Thank you for your interest in contributing to {{ project_name }}! This document provides guidelines for contributing to the project.

## Code of Conduct

We are committed to providing a welcoming and inclusive environment for all contributors. Please be respectful and considerate in all interactions.

## Getting Started

### Prerequisites

- Python {{ python_version }}+
- [uv](https://github.com/astral-sh/uv) (recommended)
- [just](https://github.com/casey/just) (optional, for task automation)
- Git

### Development Setup

1. Fork the repository on GitHub

2. Clone your fork:

```bash
git clone https://github.com/YOUR_USERNAME/{{ project_slug }}.git
cd {{ project_slug }}
```

3. Install dependencies:

```bash
uv sync --group dev
```

4. Install pre-commit hooks:

```bash
uv run pre-commit install
```

## Development Workflow

### Making Changes

1. Create a new branch:

```bash
git checkout -b feature/my-feature
```

2. Make your changes

3. Run tests:

```bash
uv run pytest
```

4. Run linters:

```bash
uvx nox -s fix
```

5. Commit your changes:

```bash
git add .
git commit -m "feat: add my feature"
```

We follow [Conventional Commits](https://www.conventionalcommits.org/) for commit messages. The commit message format is enforced by commitizen pre-commit hooks, which will validate your commit messages automatically.

**Valid commit message examples:**
- `feat: add new feature`
- `fix: resolve bug in calculation`
- `docs: update installation guide`
- `chore: update dependencies`
- `test: add tests for new feature`

### Running Tests

Run the test suite:

```bash
just test
# or directly: uv run pytest
```

Run tests with coverage:

```bash
just test-cov
# or directly: uv run pytest --cov={{ package_name }} --cov-report=html
```

Run tests across multiple Python versions:

```bash
uvx nox -s tests
```

### Code Quality

Format code and fix issues:

```bash
just format
```

Run linters and type checkers:

```bash
just lint
```

Run all quality checks:

```bash
just check
# or with nox: uvx nox -s fix
```

Run pre-commit hooks:

```bash
just pre-commit
```

### Documentation

Build documentation:

```bash
just docs
# or: uvx nox -s build_docs
```

Serve documentation locally:

```bash
just serve
# or: uvx nox -s serve_docs
```

View all available commands:

```bash
just --list
```

## Submitting Changes

1. Push your changes to your fork:

```bash
git push origin feature/my-feature
```

2. Open a Pull Request on GitHub

3. Ensure all CI checks pass

4. Wait for review and address any feedback

## Pull Request Guidelines

- Write clear, descriptive PR titles following Conventional Commits
- Include a description of the changes
- Add tests for new functionality
- Update documentation as needed
- Ensure all tests pass
- Keep PRs focused and atomic

## Commit Message Convention

We use [Conventional Commits](https://www.conventionalcommits.org/) enforced by commitizen:

- `feat:` - New features (triggers minor version bump)
- `fix:` - Bug fixes (triggers patch version bump)
- `docs:` - Documentation changes
- `style:` - Code style changes (formatting, etc.)
- `refactor:` - Code refactoring
- `test:` - Adding or updating tests
- `chore:` - Maintenance tasks
- `perf:` - Performance improvements
- `ci:` - CI/CD changes

**Breaking changes:** Add `!` after the type or add `BREAKING CHANGE:` in the footer to trigger a major version bump.

**Example with scope:**
```bash
git commit -m "feat(api): add new endpoint for user data"
```

**Example with breaking change:**
```bash
git commit -m "feat!: redesign authentication system

BREAKING CHANGE: authentication now requires API keys instead of passwords"
```

The pre-commit hook will validate your commit messages and prevent commits that don't follow the convention.

## Release Process

Releases are fully automated through GitHub Actions when a new tag is pushed.

### Initial Setup (One-time)

Before you can create releases, you need to set up a Personal Access Token:

1. **Create a Fine-grained Personal Access Token**:
   - Go to GitHub Settings â†’ Developer settings â†’ Personal access tokens â†’ Fine-grained tokens
   - Click "Generate new token"
   - Configure:
     - **Token name**: `RELEASE_AUTOMATION_TOKEN`
     - **Expiration**: 90 days or longer
     - **Repository access**: Only select repositories â†’ Choose this repository
     - **Permissions**:
       - Contents: Read and write
       - Pull requests: Read and write
       - Workflows: Read and write

2. **Add token as repository secret**:
   - Go to repository Settings â†’ Secrets and variables â†’ Actions
   - Click "New repository secret"
   - Name: `RELEASE_AUTOMATION_TOKEN`
   - Value: Paste your generated token

### How It Works

1. **Tag a release:**
   ```bash
   git tag v0.2.0
   git push origin v0.2.0
   ```

2. **Automated workflow:**
   - Generates changelog from conventional commits using git-cliff
   - Creates a **Pull Request** with the updated CHANGELOG.md
   - Builds and publishes package to PyPI
   - Creates GitHub Release with generated release notes
   - Attaches distribution files to the release

3. **Release notes generation:**
   - All commits since the last tag are analyzed
   - Commits are grouped by type (Added, Fixed, Documentation, etc.)
   - Only commits following conventional format are included
   - Breaking changes are highlighted

### Version Numbering

This project uses [Semantic Versioning](https://semver.org/):
- **Major** (1.0.0): Breaking changes
- **Minor** (0.1.0): New features (backward compatible)
- **Patch** (0.0.1): Bug fixes (backward compatible)

Use conventional commits to communicate the type of change, and select the appropriate version number when tagging.

## Questions?

If you have any questions, feel free to:

- Open an issue on GitHub
- Start a discussion in the repository

Thank you for contributing! ðŸŽ‰
